
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/generated/pygimli_dcip_century_rect_mesh.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_generated_pygimli_dcip_century_rect_mesh.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_generated_pygimli_dcip_century_rect_mesh.py:


DCIP with PyGIMLi (Real Dataset, Rectangular Mesh)
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 9-12

.. raw:: html

	<badge><a href="https://colab.research.google.com/github/inlab-geo/cofi-examples/blob/main/examples/pygimli_dcip/pygimli_dcip_century_rect_mesh.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a></badge>

.. GENERATED FROM PYTHON SOURCE LINES 15-92

.. raw:: html

   <!-- Again, please don't touch the markdown cell above. We'll generate badge 
        automatically from the above cell. -->

.. raw:: html

   <!-- This cell describes things related to environment setup, so please add more text 
        if something special (not listed below) is needed to run this notebook -->

..

   If you are running this notebook locally, make sure you’ve followed
   `steps
   here <https://github.com/inlab-geo/cofi-examples#run-the-examples-with-cofi-locally>`__
   to set up the environment. (This
   `environment.yml <https://github.com/inlab-geo/cofi-examples/blob/main/envs/environment.yml>`__
   file specifies a list of packages required to run the notebooks)

Using the DCIP (Direct Current, Induced Polarization) solver implemented
provided by `PyGIMLi <https://www.pygimli.org/>`__, we use different
``cofi`` solvers to solve problem with a real dataset.

Note: This notebook is adapted from a SimPEG example authored by Lindsey
Heagy and presented at Transform 2020. `Original
Materials <https://curvenote.com/@simpeg/transform-2020-simpeg-tutorial/!6DDumb03Le6D8N8xuJNs>`__

DCIP
----

The key difference between ERT and DCIP as implemented in PyGIMLi is
that for DCIP resistivties are expressed as complex numbers with the
real part representing the resistivtiy and the imaginary part
representing the chargeability. This means that entries into the model
vector and the data vector are complex numbers. While
``numpy.linalg.solve`` is able to call the appropriate lapack subroutine
for a complex linear system other solvers typically expect the model
vector and data vector to be real. This means that the following
transformation needs to be accounted for in the user provided functions
for the objective function, Hessian and gradient for CoFI.

The linear equation $ A x =b $ with the elements of :math:`A`, :math:`b`
and :math:`x` being complex numbers can be rewritten using real numbers
as follows

.. math::

   \begin{pmatrix}A^r & -A^c \\A^c & A^r \end{pmatrix}
   \begin{pmatrix}
   x^r \\
   x^c 
   \end{pmatrix}
   =
   \begin{pmatrix}
   b^r \\
   b^c 
   \end{pmatrix},

with :math:`b=( b_1^r+b_1^c i, b_2^r+b_2^c i,...,b_n^r+b_n^c i)` being
rewritten as :math:`(b^r,b^c)` with :math:`b^r=(b_1^r,b_2^r,...,b_n^r)`
and :math:`b^c=(b_1^c,b_2^c,...,b_n^c)` and analogus reordering for
:math:`A` and :math:`x`.

See https://ijpam.eu/contents/2012-76-1/11/11.pdf for more details.

Frequency domain vs Time domain measurements of chargeability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

References: -
https://gpg.geosci.xyz/content/induced_polarization/induced_polarization_data.html
- Martin, T., Günther, T., Orozco, A. F., & Dahlin, T. (2020).
Evaluation of spectral induced polarization field measurements in time
and frequency domain. Journal of Applied Geophysics, 180.
https://doi.org/10.1016/j.jappgeo.2020.104141 - Mutton, A. J. (2000).
The application of geophysics during evaluation of the Century zinc
deposit. Geophysics, 65(6), 1946–1960. https://doi.org/10.1190/1.1444878


.. GENERATED FROM PYTHON SOURCE LINES 95-101

1. Set up environment
---------------------

We’ll do the following: 1. Install PyGIMLi (if on CoLab) 2. Download
processed dataset (if on CoLab) 3. Import modules


.. GENERATED FROM PYTHON SOURCE LINES 101-115

.. code-block:: default


    # -------------------------------------------------------- #
    #                                                          #
    #     Uncomment below to set up environment on "colab"     #
    #                                                          #
    # -------------------------------------------------------- #

    # !pip install -U cofi

    # !pip install -q condacolab
    # import condacolab
    # condacolab.install()
    # !mamba install -c gimli pygimli=1.3








.. GENERATED FROM PYTHON SOURCE LINES 117-127

.. code-block:: default


    # -------------------------------------------------------- #
    #                                                          #
    #     Uncomment below to set up environment on "colab"     #
    #                                                          #
    # -------------------------------------------------------- #

    # !git clone https://github.com/inlab-geo/cofi-examples.git
    # %cd examples/pygimli_dcip/








.. GENERATED FROM PYTHON SOURCE LINES 132-140

We will need the following packages:

-  ``os`` to list and load dataset
-  ``numpy`` for matrices and matrix-related functions
-  ``matplotlib`` for plotting
-  ``pygimli`` for forward modelling of the problem
-  ``cofi`` for accessing different inference solvers


.. GENERATED FROM PYTHON SOURCE LINES 140-148

.. code-block:: default


    import os
    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib as mpl
    import pygimli
    import cofi








.. GENERATED FROM PYTHON SOURCE LINES 153-160

2. Load the data
----------------

We will need to download the preprocessed dataset first. This notebook
`century_data_preprocessing.ipynb <century_data_preprocessing.ipynb>`__
contains the code for data preprocessing.


.. GENERATED FROM PYTHON SOURCE LINES 160-163

.. code-block:: default


    dcip_data = np.loadtxt("century_dcip_data.txt")








.. GENERATED FROM PYTHON SOURCE LINES 165-183

.. code-block:: default


    a_locs = dcip_data[:,0]
    b_locs = dcip_data[:,1]
    m_locs = dcip_data[:,2]
    n_locs = dcip_data[:,3]
    dc_obs = dcip_data[:,4]
    dc_err = dcip_data[:,5]
    ip_obs = dcip_data[:,6]*0.7   # https://gpg.geosci.xyz/content/induced_polarization/induced_polarization_data.html
    ip_err = dcip_data[:,7]*0.7
    geo_factors = dcip_data[:,8]

    location_start = np.min(a_locs)
    location_stop = np.max(n_locs)
    location_interval = m_locs[1] - m_locs[0]
    location_num = int((location_stop - location_start) / location_interval + 1)

    location_start, location_stop, location_interval, location_num





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (26000.0, 29200.0, 100.0, 33)



.. GENERATED FROM PYTHON SOURCE LINES 185-205

.. code-block:: default


    def load_leapfrog_geologic_section(filename="century_geologic_section.csv"):
        """
        Load the geologic cross section. 
        """
        fid = open(filename, 'r')
        lines = fid.readlines()
        data = []
        data_tmp = []
        for line in lines[2:]:
            line_data = (line.split(',')[:3])
            if 'End' in line:
                data.append(np.vstack(data_tmp)[:,[0, 2]])
                data_tmp = []
            else:
                data_tmp.append(np.array(line_data, dtype=float))
        return data

    geologic_section = load_leapfrog_geologic_section()








.. GENERATED FROM PYTHON SOURCE LINES 210-217

3. Utility wrappers to PyGIMLi functions
----------------------------------------

Below we define a set of utility functions that help define the problem,
generating data and making plots. Feel free to skip reading the details
of these utility functions and come back later if you want.


.. GENERATED FROM PYTHON SOURCE LINES 220-223

3.1. Helper functions for complex numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 223-236

.. code-block:: default


    def rho_phi_to_complex(rho, phi):      # rho * e^(phi * i)
        return pygimli.utils.toComplex(rho, phi)

    def rho_phi_from_complex(complx):      # |complx|, arctan(complx.imag, complx.real)
        return np.abs(complx), np.arctan2(complx.imag, complx.real)

    def complex_to_real(complx):           # complx vector of size n -> size 2n
        return pygimli.utils.squeezeComplex(complx)

    def complex_from_real(real):           # real vector of size n -> size n/2
        return pygimli.utils.toComplex(real)








.. GENERATED FROM PYTHON SOURCE LINES 241-244

3.2. Helper functions for PyGIMLi modelling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 244-343

.. code-block:: default


    # inversion mesh bound
    x_inv_start = location_start - 1000
    x_inv_stop = location_stop + 1000
    y_inv_start = -400
    y_inv_stop = 0

    # PyGIMLi DataContainerERT
    def pygimli_data(a_locs, b_locs, m_locs, n_locs, dc_obs, dc_err, ip_obs, ip_err):
        # --- create empty data container object ---
        pg_data = pygimli.DataContainerERT()
        # create sensor locations
        for sensor in np.linspace(location_start, location_stop, location_num):
            pg_data.createSensor((sensor, 0.0, 0.0))
        # --- add indices for data points ---
        locs_sources = np.vstack((a_locs, b_locs)).T
        locs_receivers = np.vstack((m_locs, n_locs)).T
        for i in range(len(locs_sources)):
            src = locs_sources[i]
            src_idx = (src - location_start) / location_interval
            rec = locs_receivers[i]
            rec_idx = (rec - location_start) / location_interval
            pg_data.createFourPointData(i, src_idx[0], src_idx[1], rec_idx[0], rec_idx[1])
        # --- fill in the observed data and error estimation ---
        pg_data["rhoa"] = dc_obs
        pg_data["err"] = dc_err
        pg_data["phia"] = -ip_obs/1000.     # to make me happy CHECKME
        pg_data["iperr"] = ip_err/1000.
        # --- create geometric factor k ---
        pg_data["k"] = pygimli.physics.ert.createGeometricFactors(pg_data, numerical=True)
        # --- generate data vals and diag vals of covariance inv matrix in log complex space ---
        data_complex = rho_phi_to_complex(pg_data["rhoa"].array(), pg_data["phia"].array())
        data_log_complex = np.log(data_complex)
        dc_err_log = np.log(pg_data["err"])
        ip_err_log = np.log(pg_data["iperr"])
        m_err = rho_phi_to_complex(1/dc_err_log, 1/ip_err_log)
        Wd = np.diag(m_err)
        Cd_inv = Wd.conj().dot(Wd)
        return pg_data, data_log_complex, Cd_inv

    # PyGIMLi ert.ERTManager
    def ert_manager(pg_data, verbose=False):
        return pygimli.physics.ert.ERTManager(pg_data, verbose=verbose, useBert=True)

    # mesh used for inversion
    def inversion_mesh(ert_mgr):
        inv_mesh = ert_mgr.createMesh(ert_mgr.data)
        inv_mesh = inv_mesh.createH2()
        print("model size", ert_mgr.paraDomain.cellCount())
        ert_mgr.setMesh(inv_mesh)
        return inv_mesh

    # mesh used for the original paper
    def inversion_mesh_ubc(ert_mgr):
        mesh_ubc = pygimli.meshtools.readMeshIO("century_mesh.vtk")
        print("model size", mesh_ubc.cellCount())
        ert_mgr.setMesh(mesh_ubc)
        return mesh_ubc

    # PyGIMLi ert.ERTModelling
    def ert_forward_operator(ert_mgr, pg_data, inv_mesh):
        forward_oprt = ert_mgr.fop
        forward_oprt.setComplex(True)
        forward_oprt.setData(pg_data)
        forward_oprt.setMesh(inv_mesh, ignoreRegionManager=True)
        return forward_oprt

    # regularization matrix
    def reg_matrix(forward_oprt, inv_mesh):
        region_manager = forward_oprt.regionManager()
        region_manager.setConstraintType(2)
        region_manager.setMesh(inv_mesh)
        Wm = pygimli.matrix.SparseMapMatrix()
        region_manager.fillConstraints(Wm)
        Wm = pygimli.utils.sparseMatrix2coo(Wm)
        return Wm

    def starting_model(data, inv_mesh, rho_val=None, phi_val=None):
        rho_start = np.median(data["rhoa"]) if rho_val is None else rho_val
        phi_start = np.median(data["phia"]) if phi_val is None else phi_val
        start_model_val = rho_phi_to_complex(rho_start, phi_start)
        start_model_complex = np.ones(inv_mesh.cellCount()) * start_model_val
        start_model_log_complex = np.log(start_model_complex)
        start_model_log_real = complex_to_real(start_model_log_complex)
        return start_model_complex, start_model_log_complex, start_model_log_real

    def reference_dc_model():
        return np.loadtxt("century_dc_model.txt")

    def reference_ip_model():
        return -np.loadtxt("century_ip_model.txt") * 0.7 / 1000

    # initialise model to have same resistivities as the original inversion result
    def starting_model_ref(ert_mgr):
        dc_model_ref = np.loadtxt("century_dc_model.txt")
        assert ert_mgr.paraDomain.cellCount() == len(dc_model_ref), \
            "mesh cell count has to match century reference model length"
        return starting_model(ert_mgr, rhoa_val=dc_model_ref)








.. GENERATED FROM PYTHON SOURCE LINES 348-351

3.3. Plotting utilities
~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 351-413

.. code-block:: default


    def plot_geologic_section(geologic_section, ax):
        for data in geologic_section:
            ax.plot(data[:,0], data[:,1], 'k--', alpha=0.5)

    def plot_model(mesh, model_complex, title):
        rho, phi = rho_phi_from_complex(model_complex)
        fig, axes = plt.subplots(2,1,figsize=(12,5))
        pygimli.show(mesh, data=rho, label=r"$\Omega m$", ax=axes[0])
        axes[0].set_xlim(x_inv_start, x_inv_stop)
        axes[0].set_ylim(y_inv_start, y_inv_stop)
        axes[0].set_title("Resistivity")
        pygimli.show(mesh, data=phi * 1000, label=r"mrad", ax=axes[1])
        axes[1].set_xlim(x_inv_start, x_inv_stop)
        axes[1].set_ylim(y_inv_start, y_inv_stop)
        axes[1].set_title("Chargeability")
        if title != "Starting model":
            plot_geologic_section(geologic_section, axes[0])
            plot_geologic_section(geologic_section, axes[1])
        fig.suptitle(title)

    def plot_data(pg_data, data_complex, title):
        rho, phi = rho_phi_from_complex(data_complex)
        fig, axes = plt.subplots(1,2,figsize=(10,4))
        pygimli.physics.ert.showERTData(pg_data, vals=rho, label=r"$\Omega$m", ax=axes[0])
        axes[0].set_title("Apparent Resistivity")
        pygimli.physics.ert.showERTData(pg_data, vals=phi*1000, label=r"mrad", ax=axes[1])
        axes[1].set_title("Apparent Chargeability")
        fig.suptitle(title)
    
    def plot_mesh(mesh, title="Mesh used for inversion"):
        _, ax = plt.subplots(1, 1)
        pygimli.show(mesh, showMesh=True, markers=True, colorBar=False, ax=ax)
        ax.set_title(title)
        ax.set_xlabel("Northing (m)")
        ax.set_ylabel("Elevation (m)")

    def plot_comparison(mesh1, model1, title1, mesh2, model2, title2, rho_min, rho_max, phi_min, phi_max):
        rho1, phi1 = rho_phi_from_complex(model1)
        rho2, phi2 = rho_phi_from_complex(model2)
        fig, axes = plt.subplots(4, 1, figsize=(10,12))
        pygimli.show(mesh1, data=rho1, label=r"$\Omega m$", ax=axes[0])
        axes[0].set_xlim(x_inv_start, x_inv_stop)
        axes[0].set_ylim(y_inv_start, y_inv_stop)
        axes[0].set_title(f"{title1} - Resistivity")
        plot_geologic_section(geologic_section, axes[0])
        pygimli.show(mesh2, data=rho2, label=r"$\Omega m$", ax=axes[1], cMin=rho_min, cMax=rho_max)
        axes[1].set_xlim(x_inv_start, x_inv_stop)
        axes[1].set_ylim(y_inv_start, y_inv_stop)
        axes[1].set_title(f"{title2} - Resistivity")
        plot_geologic_section(geologic_section, axes[1])
        pygimli.show(mesh1, data=phi1 * 1000, label=r"mrad", ax=axes[2])
        axes[2].set_xlim(x_inv_start, x_inv_stop)
        axes[2].set_ylim(y_inv_start, y_inv_stop)
        axes[2].set_title(f"{title1} - Chargeability")
        plot_geologic_section(geologic_section, axes[2])
        pygimli.show(mesh2, data=phi2 * 1000, label=r"mrad", ax=axes[3], cMin=phi_min*1000, cMax=phi_max*1000)
        axes[3].set_xlim(x_inv_start, x_inv_stop)
        axes[3].set_ylim(y_inv_start, y_inv_stop)
        axes[3].set_title(f"{title2} - Chargeability")
        plot_geologic_section(geologic_section, axes[3])








.. GENERATED FROM PYTHON SOURCE LINES 418-424

4. PyGIMLi problem setup
------------------------

4.1. Data container
~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 424-428

.. code-block:: default


    pg_data, data_log_complex, Cd_inv = pygimli_data(a_locs, b_locs, m_locs, n_locs, dc_obs, dc_err, ip_obs, ip_err)
    pg_data





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Data: Sensors: 33 data: 151, nonzero entries: ['a', 'b', 'err', 'iperr', 'k', 'm', 'n', 'phia', 'rhoa', 'valid']



.. GENERATED FROM PYTHON SOURCE LINES 430-434

.. code-block:: default


    plot_data(pg_data, np.exp(data_log_complex), "Data Observatons")
    plot_data(pg_data, np.diag(Cd_inv), "Data covariance inverse weighting in log space")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_001.png
         :alt: Data Observatons, Apparent Resistivity, Apparent Chargeability
         :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_002.png
         :alt: Data covariance inverse weighting in log space, Apparent Resistivity, Apparent Chargeability
         :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_002.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 439-442

4.2. ERT manager
~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 442-445

.. code-block:: default


    ert_mgr = ert_manager(pg_data)








.. GENERATED FROM PYTHON SOURCE LINES 450-453

4.3. Inversion mesh
~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 453-459

.. code-block:: default


    # inv_mesh = inversion_mesh(ert_mgr)
    inv_mesh = inversion_mesh_ubc(ert_mgr)

    plot_mesh(inv_mesh)




.. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_003.png
   :alt: Mesh used for inversion
   :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    model size 2204




.. GENERATED FROM PYTHON SOURCE LINES 464-467

4.4. Forward operator
~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 467-470

.. code-block:: default


    forward_oprt = ert_forward_operator(ert_mgr, pg_data, inv_mesh)








.. GENERATED FROM PYTHON SOURCE LINES 475-478

4.5. Regularization matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 478-481

.. code-block:: default


    Wm = reg_matrix(forward_oprt, inv_mesh)








.. GENERATED FROM PYTHON SOURCE LINES 486-489

4.6. Starting model
~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 489-494

.. code-block:: default


    start_model_complex, start_model_log_complex, start_model_log_real = starting_model(pg_data, ert_mgr.paraDomain)

    plot_model(ert_mgr.paraDomain, start_model_complex, "Starting model")




.. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_004.png
   :alt: Starting model, Resistivity, Chargeability
   :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 499-516

5. Create utility functions to pass to CoFI
-------------------------------------------

CoFI and other inference packages require a set of functions that
provide the misfit, the jacobian the residual within the case of scipy
standardised interfaces. All these functions are defined below as
additional utility functions, so feel free to read them into details if
you want to understand more. These functions are:

-  ``get_response``
-  ``get_jacobian``
-  ``get_residuals``
-  ``get_data_misfit``
-  ``get_regularization``
-  ``get_gradient``
-  ``get_hessian``


.. GENERATED FROM PYTHON SOURCE LINES 516-603

.. code-block:: default


    # Utility Functions (additional)

    def _ensure_numpy(model):
        if "torch.Tensor" in str(type(model)):
            model = model.cpu().detach().numpy()
        return model

    # model_log_complex -> data_log_complex
    def get_response(model_log_complex, fop):
        model_complex = np.exp(model_log_complex)
        model_real = complex_to_real(model_complex)
        model_real = _ensure_numpy(model_real)
        data_real = np.array(fop.response(model_real))
        data_complex = complex_from_real(data_real)
        data_log_complex = np.log(data_complex)
        return data_log_complex

    # model_log_complex -> J_log_log_complex
    def get_jacobian(model_log_complex, fop):
        model_complex = np.exp(model_log_complex)
        model_real = complex_to_real(model_complex)
        model_real = _ensure_numpy(model_real)
        J_block = fop.createJacobian(model_real)
        J_real = np.array(J_block.mat(0))
        J_imag = np.array(J_block.mat(1))
        J_complex = J_real + 1j * J_imag
        data_log_complex = get_response(model_log_complex, fop)
        data_complex = np.exp(data_log_complex)
        J_log_log_complex = J_complex / data_complex[:,np.newaxis] * model_complex[np.newaxis,:]
        return J_log_log_complex

    # model_log_complex -> res_data_log_complex
    def get_residuals(model_log_complex, data_log_complex, fop):
        synth_data_log_complex = get_response(model_log_complex, fop)
        return data_log_complex - synth_data_log_complex

    # model_log_real -> obj_log_real
    def get_objective(model_log_real, data_log_complex, fop, lamda, Wm, Cd_inv):
        # convert model_log_real into complex numbers
        model_log_complex = complex_from_real(model_log_real)
        # calculate data misfit
        res_log_complex = get_residuals(model_log_complex, data_log_complex, fop)
        data_misfit = res_log_complex.conj().dot(Cd_inv).dot(res_log_complex)
        # calculate regularization term
        weighted_model_log_real = Wm.dot(model_log_complex)
        reg = lamda * weighted_model_log_real.conj().dot(weighted_model_log_real)
        # sum up
        print(f"data misfit: {np.abs(data_misfit)}, reg: {np.abs(reg)}")
        result = np.abs(data_misfit + reg)
        return result

    # model_log_real -> grad_log_real
    def get_gradient(model_log_real, data_log_complex, fop, lamda, Wm, Cd_inv):
        # convert model_log_real into complex numbers
        model_log_complex = complex_from_real(model_log_real)
        # calculate gradient for data misfit
        res = get_residuals(model_log_complex, data_log_complex, fop)
        jac = get_jacobian(model_log_complex, fop)
        data_misfit_grad = - jac.conj().T.dot(Cd_inv).dot(res)
        # calculate gradient for regularization term
        reg_grad = lamda * Wm.T.dot(Wm).dot(model_log_complex)
        # sum up
        grad_complex = data_misfit_grad + reg_grad
        grad_real = complex_to_real(grad_complex)
        return grad_real

    # model_log_real -> hess_log_real
    def get_hessian(model_log_real, data_log_complex, fop, lamda, Wm, Cd_inv):
        # convert model_log_real into complex numbers
        model_log_complex = complex_from_real(model_log_real)
        # calculate hessian for data misfit
        res = get_residuals(model_log_complex, data_log_complex, fop)
        jac = get_jacobian(model_log_complex, fop)
        data_misfit_hessian = jac.conj().T.dot(Cd_inv).dot(jac)
        # calculate hessian for regularization term
        reg_hessian = lamda * Wm.T.dot(Wm)
        # sum up
        hessian_complex = data_misfit_hessian + reg_hessian
        nparams = len(model_log_complex)
        hessian_real = np.zeros((2*nparams, 2*nparams))
        hessian_real[:nparams,:nparams] = np.real(hessian_complex)
        hessian_real[:nparams,nparams:] = -np.imag(hessian_complex)
        hessian_real[nparams:,:nparams] = np.imag(hessian_complex)
        hessian_real[nparams:,nparams:] = np.real(hessian_complex)
        return hessian_real








.. GENERATED FROM PYTHON SOURCE LINES 605-613

.. code-block:: default


    # test
    try:
        get_response(start_model_log_real, forward_oprt)
    except RuntimeError:
        print("run again")
        get_response(start_model_log_real, forward_oprt)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    run again




.. GENERATED FROM PYTHON SOURCE LINES 615-620

.. code-block:: default


    # test
    obj_val = get_objective(start_model_log_real, data_log_complex, forward_oprt, 0.0001, Wm, Cd_inv)
    obj_val





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data misfit: 16.319539850332653, reg: 0.0

    16.319539850332653



.. GENERATED FROM PYTHON SOURCE LINES 622-627

.. code-block:: default


    # test
    gradient = get_gradient(start_model_log_real, data_log_complex, forward_oprt, 0.0001, Wm, Cd_inv)
    gradient.shape, gradient





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ((4408,), 4408 [-0.0009877271233797596,...,-2.912339357301998e-07])



.. GENERATED FROM PYTHON SOURCE LINES 629-634

.. code-block:: default


    # test
    hessian = get_hessian(start_model_log_real, data_log_complex, forward_oprt, 0.0001, Wm, Cd_inv)
    hessian.shape, hessian





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ((4408, 4408), array([[ 2.00786618e-04, -9.94547039e-05,  3.41022760e-07, ...,
             4.15236556e-19,  5.31181170e-20,  6.69220727e-20],
           [-9.94547039e-05,  3.00379214e-04, -9.97627593e-05, ...,
             1.21973496e-19, -2.97641364e-21,  2.85599727e-20],
           [ 3.41022760e-07, -9.97627593e-05,  3.00148456e-04, ...,
             2.08461846e-20, -1.29535280e-20,  1.38198634e-20],
           ...,
           [ 4.15236360e-19,  1.21973382e-19,  2.08461194e-20, ...,
             3.09650163e-04, -9.72121869e-05,  4.87928282e-07],
           [ 5.31180352e-20, -2.97646230e-21, -1.29535563e-20, ...,
            -9.72121869e-05,  3.00841792e-04, -9.98438300e-05],
           [ 6.69220425e-20,  2.85599542e-20,  1.38198523e-20, ...,
             4.87928282e-07, -9.98438300e-05,  2.00031573e-04]]))



.. GENERATED FROM PYTHON SOURCE LINES 639-643

With all the above forward operations set up with PyGIMLi, we now define
the problem in ``cofi`` by setting the problem information for a
``BaseProblem`` object.


.. GENERATED FROM PYTHON SOURCE LINES 643-655

.. code-block:: default


    # hyperparameters
    lamda=0.001

    # CoFI - define BaseProblem
    dcip_problem = cofi.BaseProblem()
    dcip_problem.name = "DC-IP defined through PyGIMLi"
    dcip_problem.set_objective(get_objective, args=[data_log_complex, forward_oprt, lamda, Wm, Cd_inv])
    dcip_problem.set_gradient(get_gradient, args=[data_log_complex, forward_oprt, lamda, Wm, Cd_inv])
    dcip_problem.set_hessian(get_hessian, args=[data_log_complex, forward_oprt, lamda, Wm, Cd_inv])
    dcip_problem.set_initial_model(start_model_log_real)








.. GENERATED FROM PYTHON SOURCE LINES 657-660

.. code-block:: default


    dcip_problem.suggest_tools();





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Based on what you've provided so far, here are possible solvers:
    {
        "optimization": [
            "scipy.optimize.minimize",
            "torch.optim"
        ],
        "matrix solvers": [
            "cofi.simple_newton"
        ],
        "sampling": []
    }

    {'optimization': ['scipy.optimize.minimize', 'torch.optim'], 'matrix solvers': ['cofi.simple_newton'], 'sampling': []}



.. GENERATED FROM PYTHON SOURCE LINES 665-670

6. Define the inversion options and run
---------------------------------------

Rectangular mesh solved with SciPy’s optimizer (trust-ncg)


.. GENERATED FROM PYTHON SOURCE LINES 670-683

.. code-block:: default


    inv_options_scipy = cofi.InversionOptions()
    inv_options_scipy.set_tool("scipy.optimize.minimize")

    class CallBack:
        def __init__(self):
            self._i = 1
        def __call__(self, x):
            print(f"Iteration #{self._i}, objective value: {dcip_problem.objective(x)}")
            self._i += 1
        
    inv_options_scipy.set_params(method="trust-ncg", options={"maxiter":10}, callback=CallBack())








.. GENERATED FROM PYTHON SOURCE LINES 685-690

.. code-block:: default


    inv_scipy = cofi.Inversion(dcip_problem, inv_options_scipy)
    inv_result_scipy = inv_scipy.run()
    print(f"\nSolver message: {inv_result_scipy.message}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data misfit: 16.319539850332653, reg: 0.0
    data misfit: 11.04252539275583, reg: 0.0023580586025324676
    data misfit: 11.04252539275583, reg: 0.0023580586025324676
    Iteration #1, objective value: 11.044883451358361
    data misfit: 6.261329805330525, reg: 0.020993777955523787
    data misfit: 6.261329805330525, reg: 0.020993777955523787
    Iteration #2, objective value: 6.282323583286049
    data misfit: 2.998388974706521, reg: 0.060651388392349785
    data misfit: 2.998388974706521, reg: 0.060651388392349785
    Iteration #3, objective value: 3.059040363098871
    data misfit: 0.7301927638720261, reg: 0.09326985482946941
    data misfit: 0.7301927638720261, reg: 0.09326985482946941
    Iteration #4, objective value: 0.8234626187014955
    data misfit: 0.454988739816638, reg: 0.08835944250330433
    data misfit: 0.454988739816638, reg: 0.08835944250330433
    Iteration #5, objective value: 0.5433481823199423
    data misfit: 0.11464948194979925, reg: 0.11290700129234607
    data misfit: 0.11464948194979925, reg: 0.11290700129234607
    Iteration #6, objective value: 0.22755648324214534
    data misfit: 0.06555873110503506, reg: 0.10759975514341871
    data misfit: 0.06555873110503506, reg: 0.10759975514341871
    Iteration #7, objective value: 0.17315848624845376
    data misfit: 0.043705170748561166, reg: 0.09272083100721988
    data misfit: 0.043705170748561166, reg: 0.09272083100721988
    Iteration #8, objective value: 0.13642600175578104
    data misfit: 0.03145566881081115, reg: 0.09295411965122383
    data misfit: 0.03145566881081115, reg: 0.09295411965122383
    Iteration #9, objective value: 0.12440978846203499
    data misfit: 0.02864643215647363, reg: 0.0910025773940807
    data misfit: 0.02864643215647363, reg: 0.0910025773940807
    Iteration #10, objective value: 0.11964900955055432

    Solver message: Maximum number of iterations has been exceeded.




.. GENERATED FROM PYTHON SOURCE LINES 692-699

.. code-block:: default


    model_scipy = np.exp(complex_from_real(inv_result_scipy.model))
    # plot_model(inv_mesh, model_scipy, "Inferred model (scipy's trust-ncg)")

    synth_data_scipy = np.exp(get_response(np.log(model_scipy), forward_oprt))
    # plot_data(pg_data, synth_data_scipy, "Inferred model produced data")








.. GENERATED FROM PYTHON SOURCE LINES 704-707

Compare with UBC results
~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 707-723

.. code-block:: default


    model_ref_dc = reference_dc_model()
    model_ref_ip = reference_ip_model()
    model_ref = rho_phi_to_complex(model_ref_dc, model_ref_ip)
    plot_comparison(inv_mesh, 
                    model_ref, 
                    "Reference model", 
                    inv_mesh, 
                    model_scipy, 
                    "Inference result", 
                    np.min(model_ref_dc), 
                    np.max(model_ref_dc),
                    np.min(model_ref_ip), 
                    np.max(model_ref_ip),
                   )




.. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_005.png
   :alt: Reference model - Resistivity, Inference result - Resistivity, Reference model - Chargeability, Inference result - Chargeability
   :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_rect_mesh_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 728-733

--------------

Watermark
---------


.. GENERATED FROM PYTHON SOURCE LINES 733-739

.. code-block:: default


    watermark_list = ["cofi", "numpy", "scipy", "pygimli", "torch", "matplotlib"]
    for pkg in watermark_list:
        pkg_var = __import__(pkg)
        print(pkg, getattr(pkg_var, "__version__"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    cofi 0.1.2.dev22
    numpy 1.21.6
    scipy 1.9.1
    pygimli 1.2.6
    torch 1.12.1+cu102
    matplotlib 3.5.3





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 23 minutes  45.693 seconds)


.. _sphx_glr_download_examples_generated_pygimli_dcip_century_rect_mesh.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: pygimli_dcip_century_rect_mesh.py <pygimli_dcip_century_rect_mesh.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: pygimli_dcip_century_rect_mesh.ipynb <pygimli_dcip_century_rect_mesh.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
