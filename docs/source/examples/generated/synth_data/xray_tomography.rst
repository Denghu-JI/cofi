
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/generated/synth_data/xray_tomography.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_generated_synth_data_xray_tomography.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_generated_synth_data_xray_tomography.py:


Xray Tomography
===============

.. GENERATED FROM PYTHON SOURCE LINES 9-14

|Open In Colab|

.. |Open In Colab| image:: https://img.shields.io/badge/open%20in-Colab-b5e2fa?logo=googlecolab&style=flat-square&color=ffd670
   :target: https://colab.research.google.com/github/inlab-geo/cofi-examples/blob/main/examples/xray_tomography/xray_tomography.ipynb


.. GENERATED FROM PYTHON SOURCE LINES 17-36

.. raw:: html

   <!-- Again, please don't touch the markdown cell above. We'll generate badge 
        automatically from the above cell. -->

.. raw:: html

   <!-- This cell describes things related to environment setup, so please add more text 
        if something special (not listed below) is needed to run this notebook -->

..

   If you are running this notebook locally, make sure you’ve followed
   `steps
   here <https://github.com/inlab-geo/cofi-examples#run-the-examples-with-cofi-locally>`__
   to set up the environment. (This
   `environment.yml <https://github.com/inlab-geo/cofi-examples/blob/main/envs/environment.yml>`__
   file specifies a list of packages required to run the notebooks)


.. GENERATED FROM PYTHON SOURCE LINES 39-88

*Adapted from notebooks by Andrew Valentine & Malcolm Sambridge -
Research School of Earth Sciences, The Australian National University*

In this notebook, we look at an linear inverse problem based on Xray
Tomography. We will use ``cofi`` to run a linear system solver
(optionally with Tikhonov regularization and noise estimation) for this
problem.

As an example, we will consider performing X-Ray Tomography (XRT) to
image the interior of a structure. We assume that the x-rays travel at
the same speed regardless of the medium through which they are passing,
and so their paths are straight lines between source and receiver.
However, the medium causes the x-rays to attenuate: paths through dense
objects (such as bones!) arrive at the receiver with far less energy
than they had at the source. Thus, by analysing the attenuation along
many different paths, we can build up a picture of the interior of an
object.

Specifically, we will assume that the intensity at the receiver,
:math:`I_{rec}`, is related to the intensity at the source,
:math:`I_{src}` by

.. math:: I_{rec} = I_{src}\exp\left\{-\int_\mathrm{path} \mu(\mathbf{x})\,\mathrm{d}\mathbf{l}\right\}

\ where :math:`\mu(\mathbf{x})` is a position-dependent attenuation
coefficient. To obtain a linear inverse problem, we rewrite this as

.. math:: -\log \frac{I_{rec}}{I_{src}}=\int_\mathrm{path} \mu(\mathbf{x})\,\mathrm{d}\mathbf{l}\,.

We know that

.. math:: \int\left[f(x) + g(x)\right]\,\mathrm{d}x = \int f(x)\,\mathrm{d}x + \int g(x)\,\mathrm{d}x

so we say that integration is a *linear* operation, and hence we can
solve the XRT problem with linear inverse theory.

We will assume that the object we are interested in is 2-dimensional, so
that :math:`\mu(\boldsymbol{x}) = \mu(x,y)`. If we discretize this
model, with :math:`N_x` cells in the :math:`x`-direction and :math:`N_y`
cells in the :math:`y`-direction, we can express :math:`\mu(x,y)` as an
:math:`N_x \times N_y` vector :math:`\boldsymbol{\mu}`. This is related
to the data by

.. math:: d_i = A_{ij}\mu_j 

where :math:`d_i = -\log {I^{(i)}_{rec}}/{I^{(i)}_{src}}`, and where
:math:`A_{ij}` represents the path length in cell :math:`j` of the
discretized model.


.. GENERATED FROM PYTHON SOURCE LINES 91-96

0. Import modules
-----------------

The package ``geo-espresso`` contains the forward code for this problem.


.. GENERATED FROM PYTHON SOURCE LINES 96-106

.. code-block:: default


    # -------------------------------------------------------- #
    #                                                          #
    #     Uncomment below to set up environment on "colab"     #
    #                                                          #
    # -------------------------------------------------------- #

    # !pip install -U cofi
    # !pip install -U geo-espresso








.. GENERATED FROM PYTHON SOURCE LINES 108-113

.. code-block:: default


    import numpy as np
    from cofi import BaseProblem, InversionOptions, Inversion
    from espresso import XrayTracer








.. GENERATED FROM PYTHON SOURCE LINES 118-127

1. Define the problem
---------------------

Firstly, we get some information from the ``geo-espresso`` module. These
include the dataset and the Jacobian matrix. In the Xray Tomography
example, the Jacobian matrix is related to the lengths of paths within
each grid. Since the paths are fixed, the Jacobian matrix stays
constant.


.. GENERATED FROM PYTHON SOURCE LINES 127-130

.. code-block:: default


    xrt = XrayTracer()








.. GENERATED FROM PYTHON SOURCE LINES 132-137

.. code-block:: default


    xrt_problem = BaseProblem()
    xrt_problem.set_data(xrt.data)
    xrt_problem.set_jacobian(xrt.jacobian(xrt.starting_model))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Evaluating paths:   0%|          | 0/10416 [00:00<?, ?it/s]    Evaluating paths:   6%|6         | 635/10416 [00:00<00:01, 6349.64it/s]    Evaluating paths:  13%|#3        | 1398/10416 [00:00<00:01, 7100.58it/s]    Evaluating paths:  21%|##        | 2147/10416 [00:00<00:01, 7273.29it/s]    Evaluating paths:  28%|##7       | 2877/10416 [00:00<00:01, 7282.64it/s]    Evaluating paths:  35%|###4      | 3620/10416 [00:00<00:00, 7333.68it/s]    Evaluating paths:  42%|####1     | 4370/10416 [00:00<00:00, 7389.50it/s]    Evaluating paths:  49%|####9     | 5113/10416 [00:00<00:00, 7401.00it/s]    Evaluating paths:  56%|#####6    | 5854/10416 [00:00<00:00, 7358.08it/s]    Evaluating paths:  63%|######3   | 6612/10416 [00:00<00:00, 7425.56it/s]    Evaluating paths:  71%|#######   | 7376/10416 [00:01<00:00, 7490.65it/s]    Evaluating paths:  78%|#######8  | 8126/10416 [00:01<00:00, 7359.41it/s]    Evaluating paths:  85%|########5 | 8878/10416 [00:01<00:00, 7404.21it/s]    Evaluating paths:  92%|#########2| 9632/10416 [00:01<00:00, 7442.48it/s]    Evaluating paths: 100%|#########9| 10399/10416 [00:01<00:00, 7509.85it/s]    Evaluating paths: 100%|##########| 10416/10416 [00:01<00:00, 7383.63it/s]




.. GENERATED FROM PYTHON SOURCE LINES 142-145

We do some estimation on data noise and further perform a
regularization.


.. GENERATED FROM PYTHON SOURCE LINES 145-151

.. code-block:: default


    sigma = 0.002
    lamda = 50
    data_cov_inv = np.identity(xrt.data_size) * (1/sigma**2)
    reg_matrix = lamda * np.identity(xrt.model_size)








.. GENERATED FROM PYTHON SOURCE LINES 153-157

.. code-block:: default


    xrt_problem.set_data_covariance_inv(data_cov_inv)
    xrt_problem.set_regularization(2, 1, reg_matrix)








.. GENERATED FROM PYTHON SOURCE LINES 162-164

Review what information is included in the ``BaseProblem`` object:


.. GENERATED FROM PYTHON SOURCE LINES 164-167

.. code-block:: default


    xrt_problem.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    =====================================================================
    Summary for inversion problem: BaseProblem
    =====================================================================
    Model shape: Unknown
    ---------------------------------------------------------------------
    List of functions/properties set by you:
    ['jacobian', 'regularization', 'regularization_matrix', 'regularization_factor', 'data', 'data_covariance_inv']
    ---------------------------------------------------------------------
    List of functions/properties created based on what you have provided:
    ['jacobian_times_vector']
    ---------------------------------------------------------------------
    List of functions/properties that can be further set for the problem:
    ( not all of these may be relevant to your inversion workflow )
    ['objective', 'log_posterior', 'log_posterior_with_blobs', 'log_likelihood', 'log_prior', 'gradient', 'hessian', 'hessian_times_vector', 'residual', 'jacobian_times_vector', 'data_misfit', 'forward', 'data_covariance', 'initial_model', 'model_shape', 'blobs_dtype', 'bounds', 'constraints']




.. GENERATED FROM PYTHON SOURCE LINES 172-175

2. Define the inversion options
-------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 175-179

.. code-block:: default


    my_options = InversionOptions()
    my_options.set_tool("scipy.linalg.lstsq")








.. GENERATED FROM PYTHON SOURCE LINES 184-186

Review what’s been defined for the inversion we are about to run:


.. GENERATED FROM PYTHON SOURCE LINES 186-189

.. code-block:: default


    my_options.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    =============================
    Summary for inversion options
    =============================
    Solving method: None set
    Use `suggest_solving_methods()` to check available solving methods.
    -----------------------------
    Backend tool: `<class 'cofi.tools._scipy_lstsq.ScipyLstSq'>` - SciPy's wrapper function over LAPACK's linear least-squares solver, using 'gelsd', 'gelsy' (default), or 'gelss' as backend driver
    References: ['https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html', 'https://www.netlib.org/lapack/lug/node27.html']
    Use `suggest_tools()` to check available backend tools.
    -----------------------------
    Solver-specific parameters: None set
    Use `suggest_solver_params()` to check required/optional solver-specific parameters.




.. GENERATED FROM PYTHON SOURCE LINES 194-208

3. Start an inversion
---------------------

We can now solve the inverse problem using the Tikhonov-regularized form
of least-squares,

.. math:: \mathbf{m}=\left(\mathbf{A^TA}+\epsilon^2\sigma^2\mathbf{I}\right)^\mathbf{-1}\mathbf{A^Td}

where :math:`\sigma^2` is the variance of the expected noise on the
attenuation data.

For this dataset, we’ve taken :math:`\sigma = 0.002`\ s and chosen
:math:`\epsilon^2 = 50`.


.. GENERATED FROM PYTHON SOURCE LINES 208-213

.. code-block:: default


    inv = Inversion(xrt_problem, my_options)
    inv_result = inv.run()
    inv_result.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ============================
    Summary for inversion result
    ============================
    SUCCESS
    ----------------------------
    model: [1.13306453 0.86363911 1.01958229 ... 1.01319821 0.8615539  1.14691342]
    sum_of_squared_residuals: []
    effective_rank: 2500
    singular_values: [932638.73185699 860130.56593555 860130.56593555 ...   3644.1527398
       3379.60041023   3379.60041023]
    model_covariance: [[ 7.47520869e-05 -3.87965698e-05 -4.62858729e-06 ...  2.58820545e-08
      -8.37982995e-09 -8.03271846e-08]
     [-3.87965698e-05  1.21131273e-04 -2.70276186e-05 ... -1.63652129e-07
       1.37850692e-07 -8.37982995e-09]
     [-4.62858729e-06 -2.70276186e-05  8.87810002e-05 ...  1.30995411e-07
      -1.63652129e-07  2.58820545e-08]
     ...
     [ 2.58820545e-08 -1.63652129e-07  1.30995411e-07 ...  8.87810002e-05
      -2.70276186e-05 -4.62858729e-06]
     [-8.37982995e-09  1.37850692e-07 -1.63652129e-07 ... -2.70276186e-05
       1.21131273e-04 -3.87965698e-05]
     [-8.03271846e-08 -8.37982995e-09  2.58820545e-08 ... -4.62858729e-06
      -3.87965698e-05  7.47520869e-05]]




.. GENERATED FROM PYTHON SOURCE LINES 218-224

4. Plotting
-----------

Below the two figures refers to the inferred model and true model
respectively.


.. GENERATED FROM PYTHON SOURCE LINES 224-228

.. code-block:: default


    xrt.plot_model(inv_result.model, clim=(1, 1.5));       # inferred model
    xrt.plot_model(xrt.good_model, clim=(1, 1.5));          # true model




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_xray_tomography_001.png
         :alt: xray tomography
         :srcset: /examples/generated/synth_data/images/sphx_glr_xray_tomography_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/generated/synth_data/images/sphx_glr_xray_tomography_002.png
         :alt: xray tomography
         :srcset: /examples/generated/synth_data/images/sphx_glr_xray_tomography_002.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 2 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 233-250

5. Estimated uncertainties
--------------------------

We can now find the uncertainty on the recovered slowness parameters,
which describes how noise in the data propagate into the slowness
parameters with this data set. For the Tikhonov-regularised form of
least-squares, the model covariance matrix is a square matrix of size
:math:`M\times M`, where there are :math:`M` cells in the model.

.. math:: \mathbf{C_m}=\sigma^2\left(\mathbf{A^TA}+\epsilon^2\sigma^2\mathbf{I}\right)^\mathbf{-1}

.

This matrix was calculated as part of the solver routine above. The
square roots of the diagonal entries of this matrix are the
:math:`\sigma` errors in the slowness in each cell.


.. GENERATED FROM PYTHON SOURCE LINES 250-253

.. code-block:: default


    Cm = inv_result.model_covariance








.. GENERATED FROM PYTHON SOURCE LINES 258-261

Lets plot the slowness uncertainties as a function of position across
the cellular model.


.. GENERATED FROM PYTHON SOURCE LINES 261-264

.. code-block:: default


    xrt.plot_model(np.sqrt(np.diag(Cm)));




.. image-sg:: /examples/generated/synth_data/images/sphx_glr_xray_tomography_003.png
   :alt: xray tomography
   :srcset: /examples/generated/synth_data/images/sphx_glr_xray_tomography_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 2 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 269-283

Uncertainty is uniformly low across the entire model and only
significant near the corners where there are few ray paths.

Similarly we can calculate uncertainty in velocity parameters using some
calculus.

.. math::  \Delta v = \left | \frac{\partial s}{\partial v}  \right | \Delta s 

and since :math:`s = 1/v` we get

.. math::  \Delta v = s^2\Delta s 

which gives the uncertainty image on velocity, which looks very similar.


.. GENERATED FROM PYTHON SOURCE LINES 283-286

.. code-block:: default


    xrt.plot_model(np.sqrt(np.diag(Cm)) * inv_result.model);




.. image-sg:: /examples/generated/synth_data/images/sphx_glr_xray_tomography_004.png
   :alt: xray tomography
   :srcset: /examples/generated/synth_data/images/sphx_glr_xray_tomography_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Figure size 640x480 with 2 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 291-295

By clipping the colour range you can see an imprint of the true image,
indicating that high slowness/low velcoity areas have slightly higher
uncertainty.


.. GENERATED FROM PYTHON SOURCE LINES 298-311

--------------

Watermark
---------

.. raw:: html

   <!-- Feel free to add more modules in the watermark_list below, if more packages are used -->

.. raw:: html

   <!-- Otherwise please leave the below code cell unchanged -->


.. GENERATED FROM PYTHON SOURCE LINES 311-317

.. code-block:: default


    watermark_list = ["cofi", "espresso", "numpy", "scipy", "matplotlib"]
    for pkg in watermark_list:
        pkg_var = __import__(pkg)
        print(pkg, getattr(pkg_var, "__version__"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    cofi 0.1.3.dev2+2.g8ef207d.dirty
    espresso 0.2.2.dev0
    numpy 1.20.3
    scipy 1.10.1
    matplotlib 3.5.1




.. GENERATED FROM PYTHON SOURCE LINES 318-318

sphinx_gallery_thumbnail_number = -1


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  12.342 seconds)


.. _sphx_glr_download_examples_generated_synth_data_xray_tomography.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: xray_tomography.py <xray_tomography.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: xray_tomography.ipynb <xray_tomography.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
