
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/generated/pygimli_dcip_century_tri_mesh.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_generated_pygimli_dcip_century_tri_mesh.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_generated_pygimli_dcip_century_tri_mesh.py:


DCIP with PyGIMLi (Real Dataset, Triangular Mesh)
=================================================

.. GENERATED FROM PYTHON SOURCE LINES 9-14

|Open In Colab|

.. |Open In Colab| image:: https://img.shields.io/badge/open%20in-Colab-b5e2fa?logo=googlecolab&style=flat-square&color=ffd670
   :target: https://colab.research.google.com/github/inlab-geo/cofi-examples/blob/main/examples/pygimli_dcip/pygimli_dcip_century_tri_mesh.ipynb


.. GENERATED FROM PYTHON SOURCE LINES 17-94

.. raw:: html

   <!-- Again, please don't touch the markdown cell above. We'll generate badge 
        automatically from the above cell. -->

.. raw:: html

   <!-- This cell describes things related to environment setup, so please add more text 
        if something special (not listed below) is needed to run this notebook -->

..

   If you are running this notebook locally, make sure you’ve followed
   `steps
   here <https://github.com/inlab-geo/cofi-examples#run-the-examples-with-cofi-locally>`__
   to set up the environment. (This
   `environment.yml <https://github.com/inlab-geo/cofi-examples/blob/main/envs/environment.yml>`__
   file specifies a list of packages required to run the notebooks)

Using the DCIP (Direct Current, Induced Polarization) solver implemented
provided by `PyGIMLi <https://www.pygimli.org/>`__, we use different
``cofi`` solvers to solve problem with a real dataset.

Note: This notebook is adapted from a SimPEG example authored by Lindsey
Heagy and presented at Transform 2020. `Original
Materials <https://curvenote.com/@simpeg/transform-2020-simpeg-tutorial/!6DDumb03Le6D8N8xuJNs>`__

DCIP
----

The key difference between ERT and DCIP as implemented in PyGIMLi is
that for DCIP resistivties are expressed as complex numbers with the
real part representing the resistivtiy and the imaginary part
representing the chargeability. This means that entries into the model
vector and the data vector are complex numbers. While
``numpy.linalg.solve`` is able to call the appropriate lapack subroutine
for a complex linear system other solvers typically expect the model
vector and data vector to be real. This means that the following
transformation needs to be accounted for in the user provided functions
for the objective function, Hessian and gradient for CoFI.

The linear equation $ A x =b $ with the elements of :math:`A`, :math:`b`
and :math:`x` being complex numbers can be rewritten using real numbers
as follows

.. math::

   \begin{pmatrix}A^r & -A^c \\A^c & A^r \end{pmatrix}
   \begin{pmatrix}
   x^r \\
   x^c 
   \end{pmatrix}
   =
   \begin{pmatrix}
   b^r \\
   b^c 
   \end{pmatrix},

with :math:`b=( b_1^r+b_1^c i, b_2^r+b_2^c i,...,b_n^r+b_n^c i)` being
rewritten as :math:`(b^r,b^c)` with :math:`b^r=(b_1^r,b_2^r,...,b_n^r)`
and :math:`b^c=(b_1^c,b_2^c,...,b_n^c)` and analogus reordering for
:math:`A` and :math:`x`.

See https://ijpam.eu/contents/2012-76-1/11/11.pdf for more details.

Frequency domain vs Time domain measurements of chargeability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

References: -
https://gpg.geosci.xyz/content/induced_polarization/induced_polarization_data.html
- Martin, T., Günther, T., Orozco, A. F., & Dahlin, T. (2020).
Evaluation of spectral induced polarization field measurements in time
and frequency domain. Journal of Applied Geophysics, 180.
https://doi.org/10.1016/j.jappgeo.2020.104141 - Mutton, A. J. (2000).
The application of geophysics during evaluation of the Century zinc
deposit. Geophysics, 65(6), 1946–1960. https://doi.org/10.1190/1.1444878


.. GENERATED FROM PYTHON SOURCE LINES 97-103

1. Set up environment
---------------------

We’ll do the following: 1. Install PyGIMLi (if on CoLab) 2. Download
processed dataset (if on CoLab) 3. Import modules


.. GENERATED FROM PYTHON SOURCE LINES 103-117

.. code-block:: default


    # -------------------------------------------------------- #
    #                                                          #
    #     Uncomment below to set up environment on "colab"     #
    #                                                          #
    # -------------------------------------------------------- #

    # !pip install -U cofi

    # !pip install -q condacolab
    # import condacolab
    # condacolab.install()
    # !mamba install -c gimli pygimli=1.3








.. GENERATED FROM PYTHON SOURCE LINES 119-129

.. code-block:: default


    # -------------------------------------------------------- #
    #                                                          #
    #     Uncomment below to set up environment on "colab"     #
    #                                                          #
    # -------------------------------------------------------- #

    # !git clone https://github.com/inlab-geo/cofi-examples.git
    # %cd examples/pygimli_dcip/








.. GENERATED FROM PYTHON SOURCE LINES 134-142

We will need the following packages:

-  ``os`` to list and load dataset
-  ``numpy`` for matrices and matrix-related functions
-  ``matplotlib`` for plotting
-  ``pygimli`` for forward modelling of the problem
-  ``cofi`` for accessing different inference solvers


.. GENERATED FROM PYTHON SOURCE LINES 142-150

.. code-block:: default


    import os
    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib as mpl
    import pygimli
    import cofi








.. GENERATED FROM PYTHON SOURCE LINES 155-162

2. Load the data
----------------

We will need to download the preprocessed dataset first. This notebook
`century_data_preprocessing.ipynb <century_data_preprocessing.ipynb>`__
contains the code for data preprocessing.


.. GENERATED FROM PYTHON SOURCE LINES 162-165

.. code-block:: default


    dcip_data = np.loadtxt("century_dcip_data.txt")








.. GENERATED FROM PYTHON SOURCE LINES 167-185

.. code-block:: default


    a_locs = dcip_data[:,0]
    b_locs = dcip_data[:,1]
    m_locs = dcip_data[:,2]
    n_locs = dcip_data[:,3]
    dc_obs = dcip_data[:,4]
    dc_err = dcip_data[:,5]
    ip_obs = dcip_data[:,6]*0.7   # https://gpg.geosci.xyz/content/induced_polarization/induced_polarization_data.html
    ip_err = dcip_data[:,7]*0.7
    geo_factors = dcip_data[:,8]

    location_start = np.min(a_locs)
    location_stop = np.max(n_locs)
    location_interval = m_locs[1] - m_locs[0]
    location_num = int((location_stop - location_start) / location_interval + 1)

    location_start, location_stop, location_interval, location_num





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (26000.0, 29200.0, 100.0, 33)



.. GENERATED FROM PYTHON SOURCE LINES 187-207

.. code-block:: default


    def load_leapfrog_geologic_section(filename="century_geologic_section.csv"):
        """
        Load the geologic cross section. 
        """
        fid = open(filename, 'r')
        lines = fid.readlines()
        data = []
        data_tmp = []
        for line in lines[2:]:
            line_data = (line.split(',')[:3])
            if 'End' in line:
                data.append(np.vstack(data_tmp)[:,[0, 2]])
                data_tmp = []
            else:
                data_tmp.append(np.array(line_data, dtype=float))
        return data

    geologic_section = load_leapfrog_geologic_section()








.. GENERATED FROM PYTHON SOURCE LINES 212-219

3. Utility wrappers to PyGIMLi functions
----------------------------------------

Below we define a set of utility functions that help define the problem,
generating data and making plots. Feel free to skip reading the details
of these utility functions and come back later if you want.


.. GENERATED FROM PYTHON SOURCE LINES 222-225

3.1. Helper functions for complex numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 225-238

.. code-block:: default


    def rho_phi_to_complex(rho, phi):      # rho * e^(phi * i)
        return pygimli.utils.toComplex(rho, phi)

    def rho_phi_from_complex(complx):      # |complx|, arctan(complx.imag, complx.real)
        return np.abs(complx), np.arctan2(complx.imag, complx.real)

    def complex_to_real(complx):           # complx vector of size n -> size 2n
        return pygimli.utils.squeezeComplex(complx)

    def complex_from_real(real):           # real vector of size n -> size n/2
        return pygimli.utils.toComplex(real)








.. GENERATED FROM PYTHON SOURCE LINES 243-246

3.2. Helper functions for PyGIMLi modelling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 246-345

.. code-block:: default


    # inversion mesh bound
    x_inv_start = location_start - 1000
    x_inv_stop = location_stop + 1000
    y_inv_start = -400
    y_inv_stop = 0

    # PyGIMLi DataContainerERT
    def pygimli_data(a_locs, b_locs, m_locs, n_locs, dc_obs, dc_err, ip_obs, ip_err):
        # --- create empty data container object ---
        pg_data = pygimli.DataContainerERT()
        # create sensor locations
        for sensor in np.linspace(location_start, location_stop, location_num):
            pg_data.createSensor((sensor, 0.0, 0.0))
        # --- add indices for data points ---
        locs_sources = np.vstack((a_locs, b_locs)).T
        locs_receivers = np.vstack((m_locs, n_locs)).T
        for i in range(len(locs_sources)):
            src = locs_sources[i]
            src_idx = (src - location_start) / location_interval
            rec = locs_receivers[i]
            rec_idx = (rec - location_start) / location_interval
            pg_data.createFourPointData(i, src_idx[0], src_idx[1], rec_idx[0], rec_idx[1])
        # --- fill in the observed data and error estimation ---
        pg_data["rhoa"] = dc_obs
        pg_data["err"] = dc_err
        pg_data["phia"] = -ip_obs/1000.     # to make me happy CHECKME
        pg_data["iperr"] = ip_err/1000.
        # --- create geometric factor k ---
        pg_data["k"] = pygimli.physics.ert.createGeometricFactors(pg_data, numerical=True)
        # --- generate data vals and diag vals of covariance inv matrix in log complex space ---
        data_complex = rho_phi_to_complex(pg_data["rhoa"].array(), pg_data["phia"].array())
        data_log_complex = np.log(data_complex)
        dc_err_log = np.log(pg_data["err"])
        ip_err_log = np.log(pg_data["iperr"])
        m_err = rho_phi_to_complex(1/dc_err_log, 1/ip_err_log)
        Wd = np.diag(m_err)
        Cd_inv = Wd.conj().dot(Wd)
        return pg_data, data_log_complex, Cd_inv

    # PyGIMLi ert.ERTManager
    def ert_manager(pg_data, verbose=False):
        return pygimli.physics.ert.ERTManager(pg_data, verbose=verbose, useBert=True)

    # mesh used for inversion
    def inversion_mesh(ert_mgr):
        inv_mesh = ert_mgr.createMesh(ert_mgr.data)
        inv_mesh = inv_mesh.createH2()
        ert_mgr.setMesh(inv_mesh)
        print("model size", ert_mgr.paraDomain.cellCount())
        return inv_mesh

    # mesh used for the original paper
    def inversion_mesh_ubc(ert_mgr):
        mesh_ubc = pygimli.meshtools.readMeshIO("century_mesh.vtk")
        print("model size", mesh_ubc.cellCount())
        ert_mgr.setMesh(mesh_ubc)
        return mesh_ubc

    # PyGIMLi ert.ERTModelling
    def ert_forward_operator(ert_mgr, pg_data, inv_mesh):
        forward_oprt = ert_mgr.fop
        forward_oprt.setComplex(True)
        forward_oprt.setData(pg_data)
        forward_oprt.setMesh(inv_mesh, ignoreRegionManager=True)
        return forward_oprt

    # regularization matrix
    def reg_matrix(forward_oprt, inv_mesh):
        region_manager = forward_oprt.regionManager()
        region_manager.setConstraintType(2)
        region_manager.setMesh(inv_mesh)
        Wm = pygimli.matrix.SparseMapMatrix()
        region_manager.fillConstraints(Wm)
        Wm = pygimli.utils.sparseMatrix2coo(Wm)
        return Wm

    def starting_model(data, inv_mesh, rho_val=None, phi_val=None):
        rho_start = np.median(data["rhoa"]) if rho_val is None else rho_val
        phi_start = np.median(data["phia"]) if phi_val is None else phi_val
        start_model_val = rho_phi_to_complex(rho_start, phi_start)
        start_model_complex = np.ones(inv_mesh.cellCount()) * start_model_val
        start_model_log_complex = np.log(start_model_complex)
        start_model_log_real = complex_to_real(start_model_log_complex)
        return start_model_complex, start_model_log_complex, start_model_log_real

    def reference_dc_model():
        return np.loadtxt("century_dc_model.txt")

    def reference_ip_model():
        return -np.loadtxt("century_ip_model.txt") * 0.7 / 1000

    # initialise model to have same resistivities as the original inversion result
    def starting_model_ref(ert_mgr):
        dc_model_ref = np.loadtxt("century_dc_model.txt")
        assert ert_mgr.paraDomain.cellCount() == len(dc_model_ref), \
            "mesh cell count has to match century reference model length"
        return starting_model(ert_mgr, rhoa_val=dc_model_ref)








.. GENERATED FROM PYTHON SOURCE LINES 350-353

3.3. Plotting utilities
~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 353-415

.. code-block:: default


    def plot_geologic_section(geologic_section, ax):
        for data in geologic_section:
            ax.plot(data[:,0], data[:,1], 'k--', alpha=0.5)

    def plot_model(mesh, model_complex, title):
        rho, phi = rho_phi_from_complex(model_complex)
        fig, axes = plt.subplots(2,1,figsize=(12,5))
        pygimli.show(mesh, data=rho, label=r"$\Omega m$", ax=axes[0])
        axes[0].set_xlim(x_inv_start, x_inv_stop)
        axes[0].set_ylim(y_inv_start, y_inv_stop)
        axes[0].set_title("Resistivity")
        pygimli.show(mesh, data=phi * 1000, label=r"mrad", ax=axes[1])
        axes[1].set_xlim(x_inv_start, x_inv_stop)
        axes[1].set_ylim(y_inv_start, y_inv_stop)
        axes[1].set_title("Chargeability")
        if title != "Starting model":
            plot_geologic_section(geologic_section, axes[0])
            plot_geologic_section(geologic_section, axes[1])
        fig.suptitle(title)

    def plot_data(pg_data, data_complex, title):
        rho, phi = rho_phi_from_complex(data_complex)
        fig, axes = plt.subplots(1,2,figsize=(10,4))
        pygimli.physics.ert.showERTData(pg_data, vals=rho, label=r"$\Omega$m", ax=axes[0])
        axes[0].set_title("Apparent Resistivity")
        pygimli.physics.ert.showERTData(pg_data, vals=phi*1000, label=r"mrad", ax=axes[1])
        axes[1].set_title("Apparent Chargeability")
        fig.suptitle(title)
    
    def plot_mesh(mesh, title="Mesh used for inversion"):
        _, ax = plt.subplots(1, 1)
        pygimli.show(mesh, showMesh=True, markers=True, colorBar=False, ax=ax)
        ax.set_title(title)
        ax.set_xlabel("Northing (m)")
        ax.set_ylabel("Elevation (m)")

    def plot_comparison(mesh1, model1, title1, mesh2, model2, title2, rho_min, rho_max, phi_min, phi_max):
        rho1, phi1 = rho_phi_from_complex(model1)
        rho2, phi2 = rho_phi_from_complex(model2)
        fig, axes = plt.subplots(4, 1, figsize=(10,12))
        pygimli.show(mesh1, data=rho1, label=r"$\Omega m$", ax=axes[0])
        axes[0].set_xlim(x_inv_start, x_inv_stop)
        axes[0].set_ylim(y_inv_start, y_inv_stop)
        axes[0].set_title(f"{title1} - Resistivity")
        plot_geologic_section(geologic_section, axes[0])
        pygimli.show(mesh2, data=rho2, label=r"$\Omega m$", ax=axes[1], cMin=rho_min, cMax=rho_max)
        axes[1].set_xlim(x_inv_start, x_inv_stop)
        axes[1].set_ylim(y_inv_start, y_inv_stop)
        axes[1].set_title(f"{title2} - Resistivity")
        plot_geologic_section(geologic_section, axes[1])
        pygimli.show(mesh1, data=phi1 * 1000, label=r"mrad", ax=axes[2])
        axes[2].set_xlim(x_inv_start, x_inv_stop)
        axes[2].set_ylim(y_inv_start, y_inv_stop)
        axes[2].set_title(f"{title1} - Chargeability")
        plot_geologic_section(geologic_section, axes[2])
        pygimli.show(mesh2, data=phi2 * 1000, label=r"mrad", ax=axes[3], cMin=phi_min*1000, cMax=phi_max*1000)
        axes[3].set_xlim(x_inv_start, x_inv_stop)
        axes[3].set_ylim(y_inv_start, y_inv_stop)
        axes[3].set_title(f"{title2} - Chargeability")
        plot_geologic_section(geologic_section, axes[3])








.. GENERATED FROM PYTHON SOURCE LINES 420-426

4. PyGIMLi problem setup
------------------------

4.1. Data container
~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 426-430

.. code-block:: default


    pg_data, data_log_complex, Cd_inv = pygimli_data(a_locs, b_locs, m_locs, n_locs, dc_obs, dc_err, ip_obs, ip_err)
    pg_data





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Data: Sensors: 33 data: 151, nonzero entries: ['a', 'b', 'err', 'iperr', 'k', 'm', 'n', 'phia', 'rhoa', 'valid']



.. GENERATED FROM PYTHON SOURCE LINES 432-436

.. code-block:: default


    plot_data(pg_data, np.exp(data_log_complex), "Data Observatons")
    plot_data(pg_data, np.diag(Cd_inv), "Data covariance inverse weighting in log space")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_001.png
         :alt: Data Observatons, Apparent Resistivity, Apparent Chargeability
         :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_002.png
         :alt: Data covariance inverse weighting in log space, Apparent Resistivity, Apparent Chargeability
         :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_002.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 441-444

4.2. ERT manager
~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 444-447

.. code-block:: default


    ert_mgr = ert_manager(pg_data)








.. GENERATED FROM PYTHON SOURCE LINES 452-455

4.3. Inversion mesh
~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 455-461

.. code-block:: default


    inv_mesh = inversion_mesh(ert_mgr)
    # inv_mesh = inversion_mesh_ubc(ert_mgr)

    plot_mesh(inv_mesh)




.. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_003.png
   :alt: Mesh used for inversion
   :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    model size 1912




.. GENERATED FROM PYTHON SOURCE LINES 466-469

4.4. Forward operator
~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 469-472

.. code-block:: default


    forward_oprt = ert_forward_operator(ert_mgr, pg_data, ert_mgr.paraDomain)








.. GENERATED FROM PYTHON SOURCE LINES 477-480

4.5. Regularization matrix
~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 480-483

.. code-block:: default


    Wm = reg_matrix(forward_oprt, ert_mgr.paraDomain)








.. GENERATED FROM PYTHON SOURCE LINES 488-491

4.6. Starting model
~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 491-496

.. code-block:: default


    start_model_complex, start_model_log_complex, start_model_log_real = starting_model(pg_data, ert_mgr.paraDomain)

    plot_model(ert_mgr.paraDomain, start_model_complex, "Starting model")




.. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_004.png
   :alt: Starting model, Resistivity, Chargeability
   :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 501-518

5. Create utility functions to pass to CoFI
-------------------------------------------

CoFI and other inference packages require a set of functions that
provide the misfit, the jacobian the residual within the case of scipy
standardised interfaces. All these functions are defined below as
additional utility functions, so feel free to read them into details if
you want to understand more. These functions are:

-  ``get_response``
-  ``get_jacobian``
-  ``get_residuals``
-  ``get_data_misfit``
-  ``get_regularization``
-  ``get_gradient``
-  ``get_hessian``


.. GENERATED FROM PYTHON SOURCE LINES 518-605

.. code-block:: default


    # Utility Functions (additional)

    def _ensure_numpy(model):
        if "torch.Tensor" in str(type(model)):
            model = model.cpu().detach().numpy()
        return model

    # model_log_complex -> data_log_complex
    def get_response(model_log_complex, fop):
        model_complex = np.exp(model_log_complex)
        model_real = complex_to_real(model_complex)
        model_real = _ensure_numpy(model_real)
        data_real = np.array(fop.response(model_real))
        data_complex = complex_from_real(data_real)
        data_log_complex = np.log(data_complex)
        return data_log_complex

    # model_log_complex -> J_log_log_complex
    def get_jacobian(model_log_complex, fop):
        model_complex = np.exp(model_log_complex)
        model_real = complex_to_real(model_complex)
        model_real = _ensure_numpy(model_real)
        J_block = fop.createJacobian(model_real)
        J_real = np.array(J_block.mat(0))
        J_imag = np.array(J_block.mat(1))
        J_complex = J_real + 1j * J_imag
        data_log_complex = get_response(model_log_complex, fop)
        data_complex = np.exp(data_log_complex)
        J_log_log_complex = J_complex / data_complex[:,np.newaxis] * model_complex[np.newaxis,:]
        return J_log_log_complex

    # model_log_complex -> res_data_log_complex
    def get_residuals(model_log_complex, data_log_complex, fop):
        synth_data_log_complex = get_response(model_log_complex, fop)
        return data_log_complex - synth_data_log_complex

    # model_log_real -> obj_log_real
    def get_objective(model_log_real, data_log_complex, fop, lamda, Wm, Cd_inv):
        # convert model_log_real into complex numbers
        model_log_complex = complex_from_real(model_log_real)
        # calculate data misfit
        res_log_complex = get_residuals(model_log_complex, data_log_complex, fop)
        data_misfit = res_log_complex.conj().dot(Cd_inv).dot(res_log_complex)
        # calculate regularization term
        weighted_model_log_real = Wm.dot(model_log_complex)
        reg = lamda * weighted_model_log_real.conj().dot(weighted_model_log_real)
        # sum up
        print(f"data misfit: {np.abs(data_misfit)}, reg: {np.abs(reg)}")
        result = np.abs(data_misfit + reg)
        return result

    # model_log_real -> grad_log_real
    def get_gradient(model_log_real, data_log_complex, fop, lamda, Wm, Cd_inv):
        # convert model_log_real into complex numbers
        model_log_complex = complex_from_real(model_log_real)
        # calculate gradient for data misfit
        res = get_residuals(model_log_complex, data_log_complex, fop)
        jac = get_jacobian(model_log_complex, fop)
        data_misfit_grad = - jac.conj().T.dot(Cd_inv).dot(res)
        # calculate gradient for regularization term
        reg_grad = lamda * Wm.T.dot(Wm).dot(model_log_complex)
        # sum up
        grad_complex = data_misfit_grad + reg_grad
        grad_real = complex_to_real(grad_complex)
        return grad_real

    # model_log_real -> hess_log_real
    def get_hessian(model_log_real, data_log_complex, fop, lamda, Wm, Cd_inv):
        # convert model_log_real into complex numbers
        model_log_complex = complex_from_real(model_log_real)
        # calculate hessian for data misfit
        res = get_residuals(model_log_complex, data_log_complex, fop)
        jac = get_jacobian(model_log_complex, fop)
        data_misfit_hessian = jac.conj().T.dot(Cd_inv).dot(jac)
        # calculate hessian for regularization term
        reg_hessian = lamda * Wm.T.dot(Wm)
        # sum up
        hessian_complex = data_misfit_hessian + reg_hessian
        nparams = len(model_log_complex)
        hessian_real = np.zeros((2*nparams, 2*nparams))
        hessian_real[:nparams,:nparams] = np.real(hessian_complex)
        hessian_real[:nparams,nparams:] = -np.imag(hessian_complex)
        hessian_real[nparams:,:nparams] = np.imag(hessian_complex)
        hessian_real[nparams:,nparams:] = np.real(hessian_complex)
        return hessian_real








.. GENERATED FROM PYTHON SOURCE LINES 607-615

.. code-block:: default


    # test
    try:
        get_response(start_model_log_real, forward_oprt)
    except RuntimeError:
        print("run again")
        get_response(start_model_log_real, forward_oprt)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    run again




.. GENERATED FROM PYTHON SOURCE LINES 617-622

.. code-block:: default


    # test
    obj_val = get_objective(start_model_log_real, data_log_complex, forward_oprt, 0.0001, Wm, Cd_inv)
    obj_val





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data misfit: 16.48522124455814, reg: 0.0

    16.48522124455814



.. GENERATED FROM PYTHON SOURCE LINES 624-629

.. code-block:: default


    # test
    gradient = get_gradient(start_model_log_real, data_log_complex, forward_oprt, 0.0001, Wm, Cd_inv)
    gradient.shape, gradient





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ((3824,), 3824 [-0.03303060426138118,...,-9.278041143598141e-06])



.. GENERATED FROM PYTHON SOURCE LINES 631-636

.. code-block:: default


    # test
    hessian = get_hessian(start_model_log_real, data_log_complex, forward_oprt, 0.0001, Wm, Cd_inv)
    hessian.shape, hessian





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ((3824, 3824), array([[ 5.38948398e-03,  2.13205609e-03,  2.52937620e-03, ...,
            -5.69770033e-17, -4.42069137e-17, -4.78215494e-17],
           [ 2.13205609e-03,  1.52260555e-03,  1.36485591e-03, ...,
            -1.88550290e-17, -1.21553456e-17, -1.57566752e-17],
           [ 2.52937620e-03,  1.36485591e-03,  2.07533134e-03, ...,
            -2.71169306e-17, -1.85839507e-17, -2.24733240e-17],
           ...,
           [-5.69769934e-17, -1.88550332e-17, -2.71169294e-17, ...,
             3.01850225e-04,  1.83937474e-06, -9.81551500e-05],
           [-4.42069037e-17, -1.21553485e-17, -1.85839488e-17, ...,
             1.83937474e-06,  2.01883370e-04, -9.81077661e-05],
           [-4.78215404e-17, -1.57566759e-17, -2.24733211e-17, ...,
            -9.81551500e-05, -9.81077661e-05,  3.01974672e-04]]))



.. GENERATED FROM PYTHON SOURCE LINES 641-645

With all the above forward operations set up with PyGIMLi, we now define
the problem in ``cofi`` by setting the problem information for a
``BaseProblem`` object.


.. GENERATED FROM PYTHON SOURCE LINES 645-657

.. code-block:: default


    # hyperparameters
    lamda=0.001

    # CoFI - define BaseProblem
    dcip_problem = cofi.BaseProblem()
    dcip_problem.name = "DC-IP defined through PyGIMLi"
    dcip_problem.set_objective(get_objective, args=[data_log_complex, forward_oprt, lamda, Wm, Cd_inv])
    dcip_problem.set_gradient(get_gradient, args=[data_log_complex, forward_oprt, lamda, Wm, Cd_inv])
    dcip_problem.set_hessian(get_hessian, args=[data_log_complex, forward_oprt, lamda, Wm, Cd_inv])
    dcip_problem.set_initial_model(start_model_log_real)








.. GENERATED FROM PYTHON SOURCE LINES 659-662

.. code-block:: default


    dcip_problem.suggest_tools();





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Based on what you've provided so far, here are possible solvers:
    {
        "optimization": [
            "scipy.optimize.minimize",
            "torch.optim"
        ],
        "matrix solvers": [
            "cofi.simple_newton"
        ],
        "sampling": []
    }

    {'optimization': ['scipy.optimize.minimize', 'torch.optim'], 'matrix solvers': ['cofi.simple_newton'], 'sampling': []}



.. GENERATED FROM PYTHON SOURCE LINES 667-672

6. Define the inversion options and run
---------------------------------------

Triangular mesh solved with SciPy’s optimizer (trust-ncg)


.. GENERATED FROM PYTHON SOURCE LINES 672-685

.. code-block:: default


    inv_options_scipy = cofi.InversionOptions()
    inv_options_scipy.set_tool("scipy.optimize.minimize")

    class CallBack:
        def __init__(self):
            self._i = 1
        def __call__(self, x):
            print(f"Iteration #{self._i}, objective value: {dcip_problem.objective(x)}")
            self._i += 1
        
    inv_options_scipy.set_params(method="trust-ncg", options={"maxiter":10}, callback=CallBack())








.. GENERATED FROM PYTHON SOURCE LINES 687-692

.. code-block:: default


    inv_scipy = cofi.Inversion(dcip_problem, inv_options_scipy)
    inv_result_scipy = inv_scipy.run()
    print(f"\nSolver message: {inv_result_scipy.message}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data misfit: 16.48522124455814, reg: 0.0
    data misfit: 13.07006561380305, reg: 0.0011545790036780086
    data misfit: 13.07006561380305, reg: 0.0011545790036780086
    Iteration #1, objective value: 13.071220192806729
    data misfit: 8.149530828986657, reg: 0.010185794288192003
    data misfit: 8.149530828986657, reg: 0.010185794288192003
    Iteration #2, objective value: 8.15971662327485
    data misfit: 4.195195896394313, reg: 0.042040694840177105
    data misfit: 4.195195896394313, reg: 0.042040694840177105
    Iteration #3, objective value: 4.23723659123449
    data misfit: 1.5202708552471884, reg: 0.08827130735324643
    data misfit: 1.5202708552471884, reg: 0.08827130735324643
    Iteration #4, objective value: 1.6085421626004348
    data misfit: 0.28345234993931184, reg: 0.10407508740080823
    data misfit: 0.28345234993931184, reg: 0.10407508740080823
    Iteration #5, objective value: 0.3875274373401201
    data misfit: 0.06483596931836275, reg: 0.09306755760254946
    data misfit: 0.06483596931836275, reg: 0.09306755760254946
    Iteration #6, objective value: 0.1579035269209122
    data misfit: 0.04121562791974587, reg: 0.08547780709778989
    data misfit: 0.04121562791974587, reg: 0.08547780709778989
    Iteration #7, objective value: 0.12669343501753577
    data misfit: 0.04006485827438081, reg: 0.07218283668327996
    data misfit: 0.04006485827438081, reg: 0.07218283668327996
    Iteration #8, objective value: 0.11224769495766077
    data misfit: 0.022601473551835744, reg: 0.07086190382727325
    data misfit: 0.022601473551835744, reg: 0.07086190382727325
    Iteration #9, objective value: 0.093463377379109
    data misfit: 0.02200455034886297, reg: 0.06747037073547485
    data misfit: 0.02200455034886297, reg: 0.06747037073547485
    Iteration #10, objective value: 0.08947492108433783

    Solver message: Maximum number of iterations has been exceeded.




.. GENERATED FROM PYTHON SOURCE LINES 694-701

.. code-block:: default


    model_scipy = np.exp(complex_from_real(inv_result_scipy.model))
    # plot_model(inv_mesh, model_scipy, "Inferred model (scipy's trust-ncg)")

    synth_data_scipy = np.exp(get_response(np.log(model_scipy), forward_oprt))
    # plot_data(pg_data, synth_data_scipy, "Inferred model produced data")








.. GENERATED FROM PYTHON SOURCE LINES 706-709

Compare with UBC results
~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 709-726

.. code-block:: default


    model_ref_dc = reference_dc_model()
    model_ref_ip = reference_ip_model()
    model_ref = rho_phi_to_complex(model_ref_dc, model_ref_ip)
    mesh_ref = pygimli.meshtools.readMeshIO("century_mesh.vtk")
    plot_comparison(mesh_ref, 
                    model_ref, 
                    "Reference model", 
                    ert_mgr.paraDomain, 
                    model_scipy, 
                    "Inference result", 
                    np.min(model_ref_dc), 
                    np.max(model_ref_dc),
                    np.min(model_ref_ip), 
                    np.max(model_ref_ip),
                   )




.. image-sg:: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_005.png
   :alt: Reference model - Resistivity, Inference result - Resistivity, Reference model - Chargeability, Inference result - Chargeability
   :srcset: /examples/generated/images/sphx_glr_pygimli_dcip_century_tri_mesh_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 731-736

--------------

Watermark
---------


.. GENERATED FROM PYTHON SOURCE LINES 736-742

.. code-block:: default


    watermark_list = ["cofi", "numpy", "scipy", "pygimli", "torch", "matplotlib"]
    for pkg in watermark_list:
        pkg_var = __import__(pkg)
        print(pkg, getattr(pkg_var, "__version__"))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    cofi 0.1.2.dev22
    numpy 1.21.6
    scipy 1.9.1
    pygimli 1.2.6
    torch 1.12.1+cu102
    matplotlib 3.5.3





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  47.057 seconds)


.. _sphx_glr_download_examples_generated_pygimli_dcip_century_tri_mesh.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: pygimli_dcip_century_tri_mesh.py <pygimli_dcip_century_tri_mesh.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: pygimli_dcip_century_tri_mesh.ipynb <pygimli_dcip_century_tri_mesh.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
